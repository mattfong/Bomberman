//TODO migrate this stuff to the board class and whereever this stupid stuff neeeds to go

package gameplay;

import gameplay.gameobject.Brick;
import gameplay.gameobject.GameObject;
import gameplay.gameobject.Wall;

import java.awt.Graphics;
import java.awt.Rectangle;
import java.util.Random;

public class World {

	private final int probabilityConstant = 20;

	private int gridWidth;
	private int gridHeight;
	private final int blockSize = 32;
	public GameObject[][] grid;

	public World(int widthInBlocks, int heightInBlocks) {

		gridHeight = heightInBlocks;
		gridWidth = widthInBlocks;

		grid = new GameObject[widthInBlocks][heightInBlocks];
		fillGrid();

	}


	/**
	 * 
	 */
	public void update(){
		for (int i = 0; i < gridWidth; i++) {
			for (int j = 0; j < gridHeight; j++) {
				if (grid[i][j] != null) {
					grid[i][j].update();
				}
			}
		}
	}
	
	
	/**
	 * @param g
	 */
	public void draw(Graphics g) {
		for (int i = 0; i < gridWidth; i++) {
			for (int j = 0; j < gridHeight; j++) {
				if (grid[i][j] != null) {
					grid[i][j].draw(g);
				}
			}
		}
	}


	private void fillGrid() {

		fillTopAndBottomBorders();
		fillLeftAndRightBorders();
		fillInnerGrid();
		placeBricks();
		grid[2][1] = null; // fix later when implementing the game board.
		grid[1][2] = null; //
		grid[1][1] = null;
	}

	Random rng = new Random(4);
	double percentage;

	private void placeBricks() {
		for (int i = 0; i < gridWidth; i++) {
			for (int j = 0; j < gridHeight; j++) {
				if (grid[i][j] == null
						&& (rng.nextInt(100) >= (100 - probabilityConstant))) {
					grid[i][j] = new Brick(new Rectangle(i * blockSize, j
							* blockSize, blockSize, blockSize),this);
				}
			}
		}

	}

	private void fillTopAndBottomBorders() {
		for (int i = 0; i < gridWidth; i++) {
			// Top
			grid[i][0] = new Wall(new Rectangle(i * blockSize, 0 * blockSize,
					blockSize, blockSize),this);

			// Bottom
			grid[i][gridHeight - 1] = new Wall(new Rectangle(i * blockSize,
					(gridHeight - 1) * blockSize, blockSize, blockSize),this);

		}
	}

	private void fillLeftAndRightBorders() {
		// we can over ride the blocks that are generated by
		// fillTopAndBottomBorders() since they all get initialized to the same
		// values either way
		for (int j = 0; j < gridHeight; j++) {
			// Left
			grid[0][j] = new Wall(
						new Rectangle(0 * blockSize, j * blockSize, blockSize, blockSize),this);
			// Right
			grid[gridWidth - 1][j] = new Wall(
						new Rectangle((gridWidth - 1)* blockSize, j * blockSize, blockSize, blockSize),this);

		}
	}

	private void fillInnerGrid() {
		for (int i = 0; i < gridWidth; i = i + 2) {
			for (int j = 0; j < gridHeight; j += 2) {
				grid[i][j] = new Wall(new Rectangle(i * blockSize, j
						* blockSize, blockSize, blockSize),this);
			}
		}

	}

	public void removeGameObject(GameObject obj) {
		for (int i = 0; i < gridWidth; i++) {
			for (int j = 0; j < gridHeight; j++) {
				if (grid[i][j] == obj) {
					grid[i][j] = null;
				}
			}
		}

	}

	public int getGridWidth() {
		return gridWidth;
	}

	public int getGridHeight() {
		return gridHeight;
	}


	/**
	 * @param xCoordinate
	 * @param yCoordinate
	 * @param direction
	 * @param radius
	 */
	public void detonateSpot(int xCoordinate,int yCoordinate,Direction direction, int radius){
		
		if(radius==0){
			return;
		}
		
		int xIndex=xCoordinate/32+direction.getX();
		int yIndex=yCoordinate/32+direction.getY();
		
		if( (grid[xIndex][yIndex] != null) && (grid[xIndex][yIndex].isDestroyable() == true) ){
			GameObject o;
			o=grid[xIndex][yIndex];
			
			if(o.conductsExplosions()){
				detonateSpot(xIndex*32,yIndex*32,direction,radius-1);
			}
			
			o.remove();
			
			
			
		}

		
	}

}
